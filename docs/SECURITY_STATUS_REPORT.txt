DIGIMART - SECURITY STATUS REPORT (CURRENT STATE)
=================================================
Date: 2026-02-12

1) ARE WE USING SPRING SECURITY?
-------------------------------
YES.
- Security filter chain is enabled in the API module.
- AuthTokenFilter populates SecurityContext from Bearer token.
- Session is stateless, CSRF disabled.
- URL-level access is currently permitAll; protection happens in use cases.

Key files:
- Filter: digimart-api/src/main/java/com/nexashop/api/security/AuthTokenFilter.java
- Config: digimart-api/src/main/java/com/nexashop/api/config/SecurityConfig.java
- Current user adapter: digimart-api/src/main/java/com/nexashop/api/security/CurrentUserProviderAdapter.java


2) WHAT SECURITY IS IMPLEMENTED NOW (FACTS)
-------------------------------------------
Authentication:
- Bearer token (RefreshToken table) with SHA-256 hashing.
- Token validation in AuthTokenService (expiresAt + revokedAt is null).
- AuthTokenFilter loads user + active roles into SecurityContext.

Authorization & isolation:
- Use cases call currentUserProvider.requireUser() to enforce authentication.
- Tenant isolation is enforced inside use cases by comparing tenantId.
- SUPER_ADMIN bypass is handled manually in use cases where present.

Exception mapping:
- GlobalExceptionHandler maps Unauthorized/Forbidden/NotFound/Conflict/BadRequest.
- ExternalServiceException -> 502 Bad Gateway.

Key files:
- Token service: digimart-application/src/main/java/com/nexashop/application/service/AuthTokenService.java
- Filter: digimart-api/src/main/java/com/nexashop/api/security/AuthTokenFilter.java
- Exceptions: digimart-api/src/main/java/com/nexashop/api/exception/GlobalExceptionHandler.java


3) WHAT IS NOT YET ENFORCED (GAPS)
----------------------------------
GAP A) Role-based authorization is NOT enforced yet.
Reason: CurrentUserProviderAdapter has empty methods:
  - requireAdminAny()
  - requireOwnerOrAdmin(tenantId)
  - requireSuperAdmin()

So at runtime:
- Any authenticated user can pass admin/owner checks.
- Endpoints relying on these checks (ex: listTenants) are effectively open to any user.

GAP B) SecurityContextUtil is NOT used and has the same empty admin methods.
It is safe to ignore or remove, but it is not providing protection.

GAP C) Password hashing is weak (plain string comparison).
AuthUseCase compares raw password to stored passwordHash string.

GAP D) URL-level restrictions are not used (permitAll in SecurityConfig).
All endpoint protection depends on use case checks.


4) WHAT TO IMPROVE (PRIORITY ORDER)
-----------------------------------
P1) Implement role checks in CurrentUserProviderAdapter
   (and optionally remove SecurityContextUtil or implement it consistently).

P2) Add BCrypt or Argon2 password hashing in AuthUseCase.

P3) Add application-layer tests (use case security tests) to prevent regressions.

P4) Optional: add method-level or URL-level restrictions in Spring Security
    as a second layer (defense in depth).


5) SUMMARY (ONE-LINER)
----------------------
We use Spring Security for authentication, but admin/owner role checks are
currently disabled and passwords are still plain-compare.


6) IF WE ADD ROLE CHECKS + BCRYPT, ARE WE SECURE?
------------------------------------------------
- For demo/jury: YES (auth + roles + tenant isolation is acceptable).
- For production: NOT YET. You still need at least:
  1) Rate limiting on login/AI endpoints
  2) URL-level restrictions or strong use-case tests
  3) Proper audit logs for sensitive actions
  4) TLS + secret management + locked CORS in prod
